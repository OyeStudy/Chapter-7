
## 4. 페이징 기법
- 프로세스의 주소 공간을 동일한 크기의 페이지 단위로 나누어 물리적 메모리의 서로 다른 위치에 페이지 단위로 나누어 물리적 메모리의 서로 다른 위치에 페이지들을 저장하는 방식
- 물리적 메모리를 페이지와 동일한 크기의 프레임(frame)으로 미리 나누오 둔다.
- 연속할당에서 발생했떤 동적 메모리 할당 문제가 발생하지 않는다.
- 모든 프로세스가 각각의 주소 변환을 위한 페이지 테이블(page table)을 가지며 이 테이블은 프로세스가 가질 수 있는 페이지의 개수만큼 주소 변환 엔트리를 가지고 있게 된다.
### 1) 주소 변환 기법
- CPU가 사용하는 논리적 주소를 페이지 번호(p)와 페이지 오프셋(d)으로 나누어 주소 변환(address translation)에 사용한다.
- `페이지 번호`는 각 페이지별 주소 변환 정보를 담고 있는 페이지 테이블 접근 인덱스(index)로 사용되고 해당 인덱스의 항목(entry)에는 그 페이지의 물리적 메모리 상의 기준 주소(base address)가 저장된다.
- `페이지 오프셋`은 하나의 페이지 내에서의 변위를 알려준다.
![페이징 기법](https://velog.velcdn.com/images/zzallang/post/29d0ea35-76c7-4ad4-8e95-d911382e0d6f/image.jpg)
### 2) 페이지 테이블의 구현
- 페이지 테이블은 페이징 기법에서 주소 변환을 하기 위한 자료구조로 물리적 메모리에 위치하게 된다.

페이지 테이블에 접근하기 위해 두 개의 레지스터를 사용하는데
#### 페이지 기준 레지스터(Page-Table Base Register : PTBR)
- 메모리 내에서의 페이지 테이블의 시작 위치를 가리킨다.
#### 페이지 테이블 길이 레지스터(Page-Table Length Register : PTLR)
- 페이지 테이블의 크기를 보관
![페이지 테이블을 이용한 주소 변환](https://velog.velcdn.com/images/zzallang/post/0c35cc0e-b0e7-47cd-9f14-e5fb3cce98a6/image.png)

#### TLB
페이징 기법에서의 메모리 접근 연산은 주소 변환을 위해 **페이지 테이블에 접근하는 것**과, 변환된 주소에서 **실제 데이터에 접근하는 것** 이렇게 두 번의 메모리 접근을 필요로 해 오버헤드가 뒤따르게 된다. 이를 해결하고 메모리 접근 속도를 향상시키기 위한 고속의 주소 변환용 하드웨어 캐시
- 메모리에 비해 TLB를 사용되는 하드웨어는 가격이 비싸 빈번히 참조되는 페이지에 대한 주소 변환 정보만을 담게 된다.
- 주소 변환 정보는 프로세스별로 다르기 때문에 문맥교환시 이전 프로세스의 주소 변환 정보를 담고 있던 TLB 내용은 모두 삭제해야 한다.
- TLB를 사용한 주소 변환의 경우 페이지 번호와 이에 대응하는 프레임 번호가 쌍으로 저장되어 있어야 한다.
- TLB를 통한 주소 변환을 위해서는 TLB의 모든 엔트리를 찾아봐야 하는 오버헤드가 발생한다
- 오버헤드를 줄이기 위해 `병렬탐색`이 가능한 `연관 레지스터(associative register)`를 사용한다.
  - 병렬탐색(parallel search) : TLB 내의 모든 항목을 동시에 탐색할 수 있는 기능
  
![TLB에 의한 페이징 기법의 주소 변환](https://velog.velcdn.com/images/zzallang/post/e21c7fcb-beef-4d43-a84f-ea8ccd0258a7/image.png)


### 3) 계층적 페이징
페이지 테이블에 사용되는 메모리 공간의 낭비를 줄이기 위해 **외부 페이지 테이블(outer page table)** **내부 페이지 테이블(inner page table)** 를 걸친 두 단계의 테이블을 사용하는 `2단계 페이징(two-level paging) 기법`을 사용한다.
- 사용되지 않는 주소 공간에 대해서는 외부 페이지 테이블의 항목을 NULL로 설정하며
- 이에 대응하는 내부 페이지 테이블을 생성하지 않는 것이다.
- 1단계 페이징 기법에 비해 메모리의 낭비를 줄일 수 있지만 주소 변환을 위해 접근해야 하는 페이지 테이블의 수가 증가하므로 시간적인 손해가 뒤따른다.
- TLB를 함께 사용한면 다단계 페이지 테이블로 인해 공간적인 이득과 시간적인 효율성 또한 얻을 수 있게 된다.

![2단계 페이징에서의 주소 변환](https://velog.velcdn.com/images/zzallang/post/e3b22627-8742-43ec-b9f3-4e93778e9137/image.png)

### 4) 역페이지 테이블(inverted page table)
- 페이지 테이블로 인한 메모리 공간의 낭비를 해결하기 위한 대안
- 물리적 메모리의 페이지 프레임 하나당 페이지 테이블에 하나씩의 항목을 두는 방식(=물리적 주소에 대해 페이지 테이블을 만드는 것, 시스템 전체에 페이지 테이블을 하나만 두는 방법)
- 페이지 테이블의 각 항목은 프로세스 번호(pid)와 그 프로세스 내의 논리적 페이지 번호(p)를 담고 있게 된다.
- 일반적으로 메모리에 유지하는 대신 연고나 레지스터에 보고나해 테이블 전체 항목에 대한 병렬탐색을 가능케 함으로서 시간적 효율성을 꾀하게 된다.

![역페이지 테이블을 이용한 주소 변환](https://velog.velcdn.com/images/zzallang/post/6d0480f0-3ed7-4951-9c6e-1daed44f69d8/image.png)

### 5) 공유 페이지
- 공유 페이지(shared page) : `공유 코드`를 담고 있는 페이지
  - 공유 코드(shared code) : 
    - 메모리 공간의 효율적인 사용을 위해 여러 프로세스에 의해 공통으로 사용될수 있도록 작성한 코드 
    - 재진입 가능 코드(re-entrant code) 또는 순수 코드(pure code)라고도 불리며 읽기 전용 (read-only)의 특성을 가지고 있다
- 물리적 메모리에 하나만 적재되어 메모리를 좀 더 효율적이게 사용할 수 있게 한다.
- 공유 페이지↔`사유 페이지`
  - 사유 페이지(private page) : 프로세스들이 공유하지 않고 프로세스별로 독자적으로 사용하는 페이지(논리적 주소 공간 중 어떤 위치든 무방)
  
![운영체제 공유 페이지의 예](https://velog.velcdn.com/images/zzallang/post/0460f3f9-c02c-482e-8dda-d96d7d3ee4a7/image.png)

### 6) 메모리 보호
메모리 보호를 위한 `보호비트`와 `유효-무효 비트`를 두고 있다.
#### 보호비트(protection bit)
- 각 페이지에 대해 읽기-쓰기/읽기전용 등의 접근 권한을 설정하는데에 사용된다.
#### 유효-무효 비트(valid-invalid bit)
- '유효'일 때 :  해당 메모리 프레임에 그 페이지가 존재함을 뜻하며 접근이 허용된다
- '무효'일 때 : 프로세스가 그 주소 부분을 사용하지 않거나, 해당 페이지가 물리적으로 메모리에 올라와 있지 않고 백킹스토어에 존재해 해당 메모리 프레임에 유효한 접근 권한이 없다는 의미를 지닌다.
***
## 5. 세그먼테이션
- 프로세스의 주소 공간을 의미 단위의 `세그먼트`로 나누어 물리적 메모리에 올리는 기법
  - 세그먼트(segment) : 주소 공간을 기능 단위 또는 의미 단위로 나눈 것
  - 일반적으로 코드,데이터,스택 등의 기능 단위로 세그먼트를 정의한다
  - ※주의!※
  논리적인 단위(logical unit)로 나눈 것이기 때문에 그 크기가 균일하지 않다.
  - 이것으로 인해 오버헤드가 뒤따르게 된다
- 세그먼테이션 기법에서는 논리적 주소가 <세그먼트 번호,오프셋>으로 나뉘어 사용된다.
  - 세그먼트 번호 : 해당 논리적 주소가 프로세스 주소 공간 내에서 몇 번째 세그먼트에 속하는지를 나타낸다.
  - 오프셋 : 그 세그먼트 내에서 얼마만큼 떨어져 있는지에 대한 정보를 나타낸다.
- 세그먼테이션 기법에서는 주소 변환을 위해 세그먼트 테이블을 사용하며 세그먼트 테이블의 각 항목은 `기준점`과 `한계점`을 가지고 있다
  - 기준점(base) : 물리적 메모리에서 그 세그먼트의 시작 위치
  - 한계점(limit) : 해당 세그먼트의 길이
![세그먼테이션 기법에서의 주소 변환](https://velog.velcdn.com/images/zzallang/post/0cc806f7-4af7-43c2-a00c-bac13bfb2399/image.png)

세그먼테이션 기법에서도 `세그먼트 테이블 기준 레지스터`와 `세그먼트 테이블 길이 레지스터`
- 세그먼트 테이블 기준 레지스터(Segment Table Base Register : STBR) : 현재 CPU에서 실행 중인 프로세스의 세그먼트 테이블이 메모리의 어느 위치에 있는지 그 시작 주소를 담고 있다.
- 세그먼트 테이블 길이 레지스터(Segment Table Length Register : STLR) : 그 프로세스의 주소 공간이 총 몇 개의 세그먼트로 구성되는지 세그먼트의 개수를 나타낸다.

세그먼테이션 기법에서는 논리적 주소를 물리적 주소로 변환하기 전에 두 가지 사항을 먼저 확인한다.

>1. 요청된 세그먼트 번호가 STLR에 저장된 값보다 작은 값인지
2. 논리적 주소의 오프셋 값이 그 세그먼트의 길이보다 작은지

- 이 두 가지 사항을 모두 만족하는 경우에 한해서 유효한 메모리 접근 요청으로 판단해 주소 변환 작업이 이루어 지며 그렇지 않다면 예외상황을 발생시켜 두 가지 사항을 확인하고 그렇지 않다면 예외상황을 발생시켜 해당 메모리 위치에 대한 접근을 봉쇄하게 된다.
- 세그먼테이션 기법에서도 **보호비트와 유효비트**를 둔다.
  - 보호비트 : 각 세그먼트에 대해 읽기/쓰기/실행 권한이 있는지
  - 유효비트 : 각 세그먼트의 주소 변환 정보가 유효한지
- 세그먼테이션 기법에서도 **공유 세그먼트(shared segment)** 개념을 둔다.
  - 공유 세그먼트는 이 세그먼트를 공유하는 모든 프로세스의 주소 공간에서 동일한 논리적 주소에 위치해야 한다.
- 세그먼트는 의미 단위로 나누어져 있기 때문에 공유와 보안 측면에서 페이징 기법에 비해 훨씬 효과적이다.
***
## 6. 페이지드 세그먼테이션
- 페이징 기법과 세그먼테이션 기법의 장점만을 취하는 주소 변환 기법
- 세그먼테이션 기법과 마찬가지로 프로그램을 의미 단위의 세그먼트로 나누지만 반드시 동일한 크기 페이지들의 집합을 구성되어야 한다.
  - 하나의 세그먼트 크기를 페이지 크기의 배수가 되도록 함으로써 세그먼테이션 기법에서 발생하는 외부조각의 문제점을 해결
  - 세그먼트 단위로 프로세스 간의 공유나 프로세스 내의 접근 권한 보호가 이루어지도록 함으로써 페이징 기법의 약점을 해결
- 주소변환을 위해 외부의 세그먼트 테이블과 내부의 페이지 테이블을 이용한다.
  - 앞서 적은 2단계 페이지 테이블과 유사한 구조