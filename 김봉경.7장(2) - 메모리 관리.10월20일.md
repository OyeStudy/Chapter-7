### 4. 페이징 기법

- 프로세스의 주소 공간을 동일한 크기의 페이지 단위로 나누어 물리적 메모리의 서로 다른 위치에 페이지들을 저장하는 방식.

- 각 프로세스의 주소 공간 전체를 물리적 메모리에 한꺼번에 올릴 필요가 없다.

- 모든 프로세스가 각각의 주소 변환을 위한 `페이지 테이블(page table)`을 갖고 있다.

#### 1) 주소 변환 기법

- 페이징 기법에서는 CPU가 사용하는 논리적 주소를 `페이지 번호(p)`와 `페이지 오프셋(d)`으로 나누어 주소 변환(address translation)에 사용한다.

- `페이지 번호` : 각 페이지별 주소 변환 정보를 담고 있는 페이지 테이블 접근 시 인덱스(index)로 사용되고, 해당 인덱스의 항목(entry)에는 그 페이지의 물리적 메모리상의 기준 주소, 즉 시작위치가 저장된다.

- `페이지 오프셋` : 하나의 페이지 내에서의 변위(displacement)를 알려준다.

#### 2) 페이지 테이블의 구현

- 페이지 테이블은 페이지 기법에서 주소 변환을 하기 위한 자료구조로, 물리적 메모리에 위치하게 된다.

- 현재 CPU에서 실행 중인 프로세스의 페이지 테이블에 접근하기 위해 운영체제는 2개의 레지스터를 사용한다

  - `페이지 테이블 기준 레지스터(page-table base register)`
  메모리 내에서의 페이지 테이블의 시작 위치를 가리킨다.
  - `페이지 테이블 길이 레지스터(page-table length register)`
  페이지 테이블의 크기를 보관한다.
  
#### 3) 계층적 페이징

- 페이지 테이블에 사용되는 메모리 공간의 낭비를 줄이기 위해 `2단계 페이징(two-level paging) 기법`을 사용한다.

- 2단계 페이징 기법에서는 주소 변환을 위해 `외부 페이지 테이블(outer page table)`과 `내부 페이지 테이블(inner page table)`의 두 단계에 걸친 페이지 테이블을 사용한다.

#### 4) 역페이지 테이블

- `역페이지 테이블(inverted page table)` :
물리적 메모리의 페이지 프레임 하나당 페이지 테이블에 하나씩의 항목을 두는 방식.
즉 각 프로세스마다 페이지 테이블을 두지 않고, 시스템 전체(system-wide)에 페이지 테이블을 하나만 두는 방법.

#### 5) 공유 페이지

- `공유 코드(shared code)`는 메모리 공간의 효율적인 사용을 위해 여러 프로세스에 의해 공통으로 사용될 수 있도록 작성된 코드를 말한다.

- `공유 코드`는 `재진입 가능 코드(re-entrant code)` 또는 `순수 코드(pure code)`라고도 불리며 `읽기전용(read-only)`의 특성을 가지고 있다.

- `공유 페이지(shared page)`
공유 코드를 담고 있는 페이지

- `사유 페이지(private)`
공유 페이지와 대비되는 개념으로, 프로세스들이 공유하지 않고 프로세스별로 독자적으로 사용하는 페이지를 말한다.

#### 6) 메모리 보호

- 페이지 테이블의 각 항목에는 주소 변화 정보뿐 아니라 메모리 보호를 위한 `보호비트(protection bit)`와 `유효-무효 비트(valid-invalid bit)`를 두고 있다.

- `보호비트`
각 페이지에 대한 접근 권한의 내용을 담고 있다.

- `유효-무효 비트`
해당 페이지의 내용이 유효한지에 대한 내용을 담고 있다.

### 5. 세그먼테이션

- `세그먼테이션(segmentataion) 기법`
  - 프로세스의 주소 공간을 의미 단위의 `세그먼트(segment)`로 나누어 물리적 메모리에 올리는 기법
  - 논리적 주소가 <세그먼트 번호, 오프셋>으로 나뉘어 사용된다.
  - 주소 변환을 위해 세그먼트 테이블을 사용한다.

- `세그먼트 테이블 기준 레지스터(Segment-Table Base Register: STBR)`
현재 CPU에서 실행 중인 프로세스의 세그먼트 테이블이 메모리의 어느 위치에 있는지 그 시작 주소를 담고 있다.
- `세그먼트 테이블 길이 레지스터(Segment-Table Length Register: STLR)`
프로세스의 주소 공간이 총 몇 개의 세그먼트로 구성되는지, 즉 세그먼트의 개수를 나타낸다.

- 세그먼테이션 기법에서는 논리적 주소를 물리적 주소를 변환하기 전에 두 가지 사항을 먼저 확인한다.
  1. 요청된 세그먼트 번호가 STLR에 저장된 값보다 작은 값인가 하는 점.
  => 만약 그렇지 않다면 이는 존재하지 않는 세그먼트에 대한 접근 시도이므로 예외상황을 발생시켜 메모리 접근을 봉쇄해야 한다.
  
  2. 논리적 주소의 오프셋값이 그 세그먼트의 길이보다 작은 값인가 하는 점.
  => 만약 세그먼트 길이를 넘어서는 오프셋 위치에 대한 접근 시도라면 예외상황을 발생시켜 해당 메모리 위치에 대한 접근을 봉쇄해야 한다.
  
- 페이징 기법과 마찬가지로 세그먼테이션 기법에서도 세그먼트 테이블의 각 항목에 `보호비트`와 `유효비트`를 둔다.

- 세그먼트는 의미 단위로 나누어져 있기 때문에 공유와 보안의 측면에서 페이징 기법에 비해 훨씬 효과적이다.

### 6. 페이지드 세그먼테이션

- 페이징 기법과 세그먼테이션 기법의 장점만을 취하는 주소 변환 기법으로 `페이지드 세그먼테이션(paged segmentation) 기법`을 생각해볼 수 있다.

- 세그먼테이션 기법과 마찬가지로 프로그램을 의미 단위의 세그먼트로 나눈다.
=> 단 세그먼트가 임의의 길이를 가질 수 있는 것이 아니라 반드시 동일한 크기 페이지들의 집합으로 구성되어야 한다.

- 주소 변환을 위해 외부의 세그먼트 테이블과 내부의 페이지 테이블, 이렇게 두 단계의 테이블을 이용한다.

---
