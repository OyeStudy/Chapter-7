

# 4.페이징 기법

 페이징 기법이란 프로세스의 주소 공간을 동일한 크기의 페이지 단위로 나누어 물리적 메모리의 서로 다른 위치에 페이지들을 저장하는 방식을 말한다. 프로세스의 가상메모리를 동일한 사이즈의 page 단위로 나눈다.
가상메모리의 내용이 page단위로 불연속적으로 저장되고, 일부는 백킹스토리지에, 일부는 물리메모리에 저장된다. Paging(페이징)은 Noncontiguous Allocation 방식이다. 외부 단편화의 압축 작업의 비효율성을 해결하기 위한 방법으로, 메모리는 프레임(Frame), 프로세스는 페이지(Page)라 불리는 고정 크기의 블록(Block)으로 분리된다. 블록의 크기는 2의 거듭제곱 이다. 
한 프로세스가 사용하는 공간은 여러 page로 나뉘어 관리되고, 각각의 page는 순서와 관계없이 메모리의 frame에 mapping 되어 저장된다. 프로세스가 순서대로 메모리에 저장되지 않기 때문에 프로세스를 실행하기 위해선 page가 어느 frame에 들어있는지를 알아야 한다. 이에 대한 정보가 page table이라는 테이블에 저장되어 있고, 이를 사용하여 논리적 주소를 물리적 주소로 변환한다.

1) 주소 변환 기법

 페이징 기법에서는 CPU가 사용하는 논리적 주소를 페이지 번호(p)와 페이지 오프셋(d)으로 나누어 주소 변환에 사용한다.
페이지 번호는 각 페이지별 주소 변환 정보를 담고 있는 페이지 테이블 접근 시 인덱스로 사용되고, 해당 인덱스의 항목에는 그 페이지의 물리적 메모리 상의 기준 주소, 즉 시작 위치가 저장된다.
따라서 특정 프로세스의 p번째 페이지가 위치한 물리적 메모리의 시작 위치를 알고 싶다면 해당 프로세스의 페이지 테이블에서 p번째 항목을 찾아보면 된다.
페이지 오프셋은 하나의 페이지 내에서의 변위를 알려준다. 따라서 기준 주소 값에 변위를 더함으로써 요청된 논리적 주소에 대응하는 물리적 주소를 얻을 수 있다.

2) 페이지 테이블의 구현

 페이지 테이블은 페이징 기법에서 주소 변환을 하기 위한 자료 구조로, 물리적 메모리인 Main Memory에 상주한다. 현재 CPU에서 실행 중인 프로세스의 페이지 테이블에 접근하기 위해 운영체제는 2개의 레지스터를 사용한다.

- 페이지 테이블 기준 레지스터(page-table base register)
	메모리 내에서 페이지 테이블의 시작 위치를 가리킨다.
 - 페이지 테이블 길이 레지스터(page-table length register)
	페이지 테이블의 크기를 보관을 한다.

 페이징 기법에서 모든 메모리 접근 연산은 총 2번씩 필요하며 주소 변환을 위해 페이지 테이블에 접근
변환된 주소에서 실제 데이터에 접근 이러한 오버헤드를 줄이고 메모리의 접근 속도를 향상하기 위해 TLB(Translation Lock-aside Buffer)라고 불리는 고속의 주소 변환용 하드웨어 캐시를 사용한다.

 TLB는 가격이 비싸기 때문에 빈번히 참조되는 페이지에 대한 주소 변환 정보만 담게 된다.
요청된 페이지 번호가 TLB에 존재한다면 곧바로 대응하는 물리적 메모리의 프레임 번호를 얻을 수 있지만, TLB에 존재하지 않는 경우에는 메인 메모리에 있는 페이지 테이블로부터 프레임 번호를 알아내야 한다.
페이지 테이블에는 페이지 번호가 주어지면 해당 페이지에 대응하는 프레임 번호를 얻을 수 있지만, TLB에는 페이지 번호와 프레임 번호 쌍을 가지고 있으므로 특정 페이지 번호가 있는지 TLB 전체를 찾아봐야 한다.
이때 TLB 풀 스캔 시간이 오래 걸리므로 병렬적으로 탐색이 가능한 연관 레지스터를 사용한다.
TLB는 context switch 이전 프로세스의 주소 변환 정보를 담고 있는 내용이 전부 지워진다.


3) 계층적 페이징

 현대의 컴퓨터는 주소 공간이 매우 큰 프로그램을 지원한다.
예를 들어 32비트 주소 체계를 사용하는 컴퓨터에서는 4GB의 주소 공간을 갖는 프로그램을 지원한다.
그러나 대부분의 프로그램은 4G의 주소 공간 중 지극히 일부분만 사용하므로 페이지 테이블 공간이 심하게 낭비된다. 위 문제로 인하여 페이지 테이블 자체를 페이지로 구성하는 2단계 페이징 기법을 사용한다.

 주소 변환을 위해 외부 페이지 테이블과 내부 페이지 테이블의 두 단계에 걸친 페이지 테이블을 사용한다.
사용하지 않는 주소 공간에 대해서는 외부 페이지 테이블의 항목을 NULL로 설정하며, 여기에 대응하는 내부 페이지 테이블을 생성하지 않는다.
페이지 테이블을 위해 사용되는 메모리 공간을 줄이지만, 페이지 테이블의 수가 증가하므로 시간적인 손해가 뒤따른다.

프로세스의 주소 공간이 커질수록 페이지 테이블의 크기도 커지므로 주소 변환을 위한 메모리 공간 낭비가 심해진다. 다단계 페이지 테이블을 사용하면 페이지 테이블을 위해 사용되는 메모리 공간의 소모를 줄일 수 있지만, 메모리 접근 시간이 늘어나기 때문에 TLB를 통해 메모리 접근 시간을 줄일 수 있다.


4) 역페이지 테이블

 페이지 테이블로 인한 메모리 공간의 낭비가 심한 이유는 모든 프로세스의 모든 페이지에 대한 페이지 테이블 항목을 구성해야 하기 때문이다. 이 문제를 해결하기 위해 역페이지 기법을 사용할 수 있다.
물리적 메모리의 페이지 프레임 하나당 페이지 테이블에 하나씩의 항목을 두는 방식이다.
논리적 주소에 대해 페이지 테이블을 만드는 것이 아니라, 물리적 주소에 대해 페이지 테이블을 만드는 것이다.
시스템 전체에 페이지 테이블을 하나만 두과, 페이지 테이블의 각 항목은 어느 프로세스의 어느 페이지가 이 프레임에 저장되었는지의 정보를 보관하고 있다.
페이지 테이블의 각 항목은 프로세스 번호(pid)와 그 프로세스 내의 논리적 페이지 번호(p)를 담고 있다.
페이지 전체를 탐색해야 하는 단점이 있다. 따라서 일반적으로 연관 레지스터를 사용하여 병렬 탐색을 수행한다.

5) 공유 페이지

 공유 코드는 메모리 공간의 효율적인 사용을 위해 여러 프로세스에 의해 공통적으로 될 수 있도록 작성된 코드를 말한다. 재진입 가능 코드, 순수 코드라고도 불리며, 읽기 전용의 특성을 가지고 있다.
공유 페이지는 공유 코드를 담고 있는 페이지를 말하고,여러 프로세스에 의해 공유되는 페이지이므로 물리적 메모리에 하나만 적재되어 메모리를 효율적으로 사용할 수 있다.
예를 들어 문서 편집기 프로그램을 공유 페이지를 사용해서 작성한 경우, 이 프로세스를 여러 개 수행하더라도 공유 코드를 담은 페이지는 메모리에 하나만 올라간다.
공유 코드는 읽기 전용의 성질을 가져야 하고 모든 프로세스의 논리적 주소 공간에서 동일한 위치에 존재해야 한다.
사유 페이지는 프로세스들이 공유하지 않고, 프로세스 별로 독자적으로 사용하는 페이지를 뜻한다.
사유 페이지는 해당 프로세스의 논리적 주소 공간 중 어떠한 위치에 있어도 무방하다.

6)메모리 보호

페이지 테이블의 각 항목에는 주소 변환 정보 외에 메모리 보호를 위한 보호 비트와 유효-무효 비트가 존재한다. 보호 비트는 각 페이지에 대해 읽기-쓰기/읽기 전용 등의 접근 권한을 설정하는 데 사용된다.
유효-무효 비트는 해당 페이지의 내용이 유효한 지에 대한 내용을 담고 있다.
유효-무효 비트가 유효 일때는 해당 메모리 프레임에 해당 페이지가 존재하므로 접근 허용을 한다.
유효-무효 비트가 무효 일때는 해당 페이지가 물리적 메모리에 올라와 있지 않고, backing store에 존재하여 해당 메모리 프레임에 접근 권한이 없다.


# 5.세그먼테이션

Segmentation은 의미 단위로 하나의 프로세스를 나누는 것을 말한다. 작게는 프로그램을 구성하는 함수 하나하나를, 크게는 프로그램 전체를 하나의 Segment로 정의할 수 있다. 일반적으로는 code, data, stack 부분이 하나의 


Segmentation의 논리적 주소는 segment number, offset으로 구성되며, 각각의 segment는 base, limit, protection bit을 가지고 있다.

Segmentation의 장점으로는 공유와 보안의 측면에서 많이 효과적이며,  paging과 마찬가지로 segment들이 연속적으로 할당될 필요가 없고, stack과 heap이 독립적으로 커질 수 있으며, segment마다 protection을 따로 수행할 수 있는 등 paging과 유사한 장점을 가지고 있다.

다만, 각각의 segment는 반드시 연속적으로 할당해야 하는 단점이 있다. 

세그먼트를 가용 공간에 할당하는 방식에는  최초적합 방식과, 최적적합 방식이 있다.
최초적합 방식은 해당 세그먼트 크기보다 크거나 같은 첫번째 가용공간에 할당하는 방식이고,
최적적합 방식은 세그먼트 크기보다 크거나 같은 가용 공간 중 가장 작은 공간에 할당하는 최적접합 방식이있다.

# 6.페이지드 세그먼테이션

Paged Segmentation의 장/단점이 있는데 장점으로는 
기존의 Paging 기법만 사용했을 때보다 Page의 크기를 줄일 수 있지만 단점으로는 메모리 참조가 한 번더 증가하여 속도 저하의 문제점이 있다.

Segmentation을 먼저 진행한 후, Paging 기법을 통해 Memory를 할당한다.
일반적으로 Paging 기법을 적용했다는 것은 해당 Process를 하나의 Segment로 다루었다는 것이다.
Segment Table에는 각 Segment의 Base Address대신 Page Table의 위치가 저장된다.
또한 기존의 Bound값 대신 Page의 개수를 저장한다.
(Segment Table은 MMU 내부에 해당 Table를 가리키는 Register가 존재한다고 한다.)

기본적으로 Virtual Address가 주어지고 그에 따라 위와같은 단계를 거쳐 물리적 주소를 구할 수 있다.




