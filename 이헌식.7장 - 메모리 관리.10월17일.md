프로그래밍에서의 주소란 서로 다른 위치를 구분하기 위해 사용하는 일련의 숫자로 구성되어있는 것을 뜻 합니다. 컴퓨터의 주소는 계층적으로 나뉘어져 있는데, 요즘은 32,64비트를 많이 사용하게 되는데 32,64비트를 그대로 사용하지 않고 효율적인 운영을 위해 연속된 일련의 행정구역처럼 묶어서 사용합니다. 이 때 32비트의 주소 중 하위 12비트는 페이지 내에서의 주소를 나타낸다고 합니다. 메모리를 어떠한 행정구역으로 나누어 관리 할 것인지 살펴보고, 프로그램이 물리적 메모리에 어떻게 올라가서 주소를 할당받게 되는지 알아보기전에

논리적 주소 와 물리적 주소의 차이를 알아둘 필요가 있는데,
논리적 주소란(가상 주소) 즉 프로세스마다 독립적으로 가지는 주소 공간을 뜻하며,
각 프로세스마다 0번지부터 시작하고 CPU가 보는 주소는 논리적 주소입니다.

물리적 주소는 메모리에 실제로 올라가는 위치를 말하며, 보통 메모리의 낮은 주소 영역에는 운영체제가 올라가고, 높은 주소 영역에는 사용자 프로세스가 올라갑니다.

# 1. 주소 바인딩

주소 바인딩이란 프로세스의 논리적 주소를 물리적 메모리 주소로 연결시켜주는 작업을 말 합니다.

주소 바인딩 방식은 프로그램이 적재되는 물리적 메모리의 주소가 결정되는 시기에 따라 세가지로 분류할 수 있습니다. 

1. compile time binding (absolute code)
 -물리적 메모리 주소가 프로그램을 컴파일 할 때 결정되는 주소 바인딩 방식입니다.
비현실적이고 현댜의 시분할 컴퓨팅 환경에서는 잘 사용하지 않는다고 합니다.

2. load time binding 
 -프로그램의 실행이 시작될 때에 물리적 메모리 주소가 결정되는 주소 바인딩 방식입니다.
 loader란 사용자 프로그램을 메모리에 적재키는 프로그램이고 로더의 책임하에 물리적 메모리 주소가 부여되며 프로그램이 종료될 때 까지 물리적 메모리상의 위치가 고정됩니다.
컴파일러가 재배치 가능 코드를 생성한 경우에 가능한 주소바인딩 입니다.

3. execution time binding 또는 Run time binding (실행시간 바인딩)
 -프로그램이 실행을 시작한 후에도 그 프로그램이 위치한 물리적 메모리상의 주소가 변경될 수 있는 바인딩 방식입니다. 주소 매핑 테이블을 이용해 바인딩을 점검하고, 기준 레지스터와 한계 레지스터를 포함해 MMU(논리적 주소를 물리적 주소로 매핑해주는 하드웨어 장치) 라는 하드웨어적인 자원이 뒷받침이 되어야합니다.
 
MMU (Memory-Management Unit)
실행시간 바인딩을 설명하면서 말씀 드렸지만 MMU는 논리적 주소를 물리적 주소로 매핑해 주는 하드웨어 장치입니다.
MMU를 사용한 기법을 MMU Scheme라고 하는데, 사용자 프로세스가 CPU에서 수행되며 생성해 내는 모든 주소 값에 대해 기준 레지스터의 값을 더하는 방식을 말합니다
MMU 기법에서 사용자 프로그램이나 CPU는 논리적 주소만을 다룰 뿐, 실제 메모리 주소는 알지 못하며 알아야 할 필요도 없다고 합니다.
 
CPU가 논리적 메모리 346번지에 있는 내용을 달라고 하면, MMU는 2개의 레지스터를 가지고 변환을 하게 되는데,실제 물리적 메모리의 시작 위치와 논리적 메모리 주소를 더한 값을 CPU에게 전달을 합니다. 논리적 메모리 주소는 offset 개념으로 생각할 수 있수 있습니다.
기준 레지스터(재배치 레지스터)가 물리적 메모리의 시작 위치를 갖고 있으며, 접근할 수 있는 물리적 메모리 주소의 최솟값에 해당합니다
한계 레지스터는 프로그램의 크기를 나타내며 논리적 주소의 범위를 뜻하고, 이 범위를 넘어서는 주소를 요청하면 안 된다고 합니다.
 
위 순서도와 같이 CPU가 요청한 논리적 주소 값을 한계 레지스터와 비교하여 범위를 넘어서면 trap을 발생시켜 프로세스를 강제 종료합니다.
그렇지 않으면 기준 레지스터(재배치 레지스터)의 값을 더해서 물리적 주소로 변환합니다.
이렇듯, 사용자 프로그램은 논리적 주소만 다루므로 실제 물리적 주소를 알 필요는 없습니다.
 
# 2.메모리 관리와 관련된 용어
1)동적 로딩
동적로딩은 프로세스 전체를 메모리에 미리 다 올리는 것이 아니라 해당 루틴이 불려질 때 메모리에 load하는 것을 말합니다. load는 메모리에 올라간다는 뜻이고,Memory Utilization이 향상된다고 합니다. 가끔씩 사용되는 많은 양의 코드의 경우(ex:오류 처리루틴)유용하고, 운영체제의 특별한 지원 없이 프로그램 자체에서 구현이 가능하며, 운영체제가 라이브러리를 통해 지원할 수도 있습니다.

2)동적 연결
연결(linking)이란 프로그래머가 작성한 소스 코드를 컴파일하여 생성된 목적 파일(object file)과 이미 컴파일된 라이브러리 파일들을 묶어 하나의 실행 파일을 생성하는 과정입니다.
동적 연결은 컴파일을 통해 생성된 목적 파일과 라이브러리 파일 사이의 연결을 프로그램의 실행 시점까지 지연하는 기법입니다.

-정적 연결
라이브러리가 프로그램의 실행 파일 코드에 포함되고, 실행 파일의 크기가 커집니다.
동일한 라이브러리를 각각의 프로세스가 메모리에 올리므로 메모리 낭비가 심합니다.
(ex. printf 함수의 라이브러리 코드)

-동적 연결
실행 파일에 라이브러리 코드가 포함되지 않으며, 프로그램이 실행되면서 라이브러리 함수를 호출할 때가 되어서야 라이브러리에 대한 연결이 이루어집니다.
라이브러리 호출 부분에 라이브러리 루틴의 위치를 찾기 위한 stub이라는 작은 코드를 둡니다.
라이브러리가 이미 메모리에 있으면 그 루틴의 주소로 가고, 없으면 디스크에서 읽어 옵니다.
운영 체제의 도움이 필요하는 연결입니다.
 
3) Overlays(중첩)
메모리에 프로세스의 부분 중 실제 필요한 정보만을 올리는 기법입니다.
초창기 컴퓨터 시스템에서 물리적 메모리의 크기 제약으로 인해 하나의 프로세스조차도 메모리에 한꺼번에 올릴 수 없을 때, 프로세스의 주소 공간을 분할해서 당장 필요한 일부분을 메모리에 올려 실행하고 해당 부분에 대한 실행이 끝난 후에 나머지 부분을 올려 실행하는 기법을 뜻합니다.
프로세스의 크기가 메모리보다 클 때 유용합니다.
작은 공간의 메모리를 사용하던 초창기 시스템에서 운영체제의 지원 없이 수작업으로 프로그래머가 구현하였으며, 수작업 오버랩을 하면 프로그래밍이 상당히 복잡해집니다.

동적 로딩과 오버랩의 차이점은
동적 로딩은 다중 프로세스 환경에서 메모리에 더 많은 프로세스를 동시에 올려놓고 실행하기 위한 용도로 많이 사용되며,
오버랩은 단일 프로세스만을 메모리에 올려놓는 환경에서 메모리 용량보다 큰 프로세스를 올리기 위한 어쩔 수 없는 선택이라고 합니다.
 

4)Swapping (스와핑)
메모리에 올라온 프로세스의 주소 공간 전체를 디스크의 backing store로 쫓아내는 것입니다.
backing store는 swap area라고 부르며, 디스크 내에 파일 시스템과는 별도로 존재하는 많은 사용자의 프로세스를 담을 만큼 충분히 빠르고 큰 저장 공간입니다.
디스크에서 메모리로 올리는 작업을 swap in, 메모리에서 디스크로 내리는 작업을 swap out라고 부릅니다. swap이 일어나는 과정 으로는
일반적으로 중기 스케줄러가 swap out할 프로세스를 선정을 하고,
주로, 우선 순위 기반 CPU 스케줄링을 사용합니다.
우선 순위가 낮은 프로세스를 swap out하고,
우선 순위가 높은 프로세스를 swap in합니다.
만약 컴파일 타임 바인딩 혹은 로드 타임 바인딩이 사용되고 있다면, swap out되었다가 swap in이 되면 원래 존재하던 메모리 위치로 다시 올라가야 한다고 합니다.
반면 런타임 바인딩이 사용되고 있다면, 추후 빈 메모리 영역 아무 곳에나 프로세스를 올릴 수 있으므로 Swapping에 적합합니다.
swap time은 디스크의 탐색 시간이나 회전 지연 시간 보다는 디스크 섹터에서 실제 데이터를 읽고 쓰는 전송 시간(transfer time)이 대부분을 차지합니다.
 


 

# 3. 물리적 메모리의 할당 방식
물리적 메모리는 운영체제 상주 영역과 사용자 프로세스 영역으로 나뉘고,운영체제 상주 영역은 인터럽트 벡터와 함께 낮은 주소 영역을 사용합니다. 사용자 프로세스 영역은 높은 주소 영역을 사용을 하게 됩니다. 사용자 프로세스 영역의 할당 방법으로는 
연속 할당과 불연속 할당이 있는데
연속 할당은 각각의 프로세스가 메모리의 연속적인 공간에 적재되도록 하는 것입니다.
고정 분할 방식과 가변 분할 방식이 존재합니다.
불연속 할당은 하나의 프로세스가 메모리의 여러 영역에 분산되어 올라가는 것입니다.
Paging, Segmentaing, Paged Segmentation 방식이 존재한다고 하네요.
 

1)연속 할당
연속할당 방식은 프로세스를 메모리에 올릴 때 그 주소 공간을 여러 개로 분할하지 않고 물리적 메모리의 한 곳에 연속적으로 적재하는 방식입니다.
메모리를 고정된 크리의 분할로 미리 나누어 놓는지 아닌지로 고정분할 방식과 가변분할 방식으로 나뉩니다.
 
 -고정 분할 방식은 메모리를 주어진 개수만큼의 영구적인 파티션으로 미리 나누어두고 각 파티션에 하나의 프로세스를 적재해 실행합니다.
동시에 메모리에 올릴 수 있는 프로그램의 수가 고정되어 있으며 수행 가능한 프로그램의 최대 크기 또한 제한된다는 점에서 융통성이 떨어집니다. 외부 조각과 내부 조각이 발생할 수 있으며,외부 조각은 프로그램의 크기보다 파티션의 크기가 작은 경우 해당 파티션이 비어있는 데도 불구하고 프로그램을 적재하지 못하기 때문에 생기는 메모리 공간을 의미합니다. 보통 사용자가 올리려는 프로그램보다 메모리 크기가 작습니다.
내부 조각은 프로그램의 크기보다 파티션의 크기가 큰 경우 해당 파티션에 프로그램을 적재하고 남는 메모리 공간을 의미합니다. 내가 올리려는 프로그램보다 메모리 크기가 큽니다.
 

-가변 분할 방식은메모리에 적재되는 프로그램의 크기에 따라 파티션의 크기, 개수가 동적으로 변하는 방식입니다. 고정 분할 방식과 달리 미리 메모리 영역을 나누어 놓지 않고,
프로그램이 실행될 때마다 차곡차곡 메모리에 올리므로 내부 조각이 발생하지 않습니다.
다만 중간에 프로그램이 종료되어 메모리에서 빠져 나가고, 그 공간에 새로운 프로그램이 메모리에 할당될 경우 외부 조각이 발생할 수 있다고 합니다.
 

2) 불연속 할당 기법
하나의 프로세스가 물리적 메모리의 여러 위치에 분산되어 올라갈 수 있는 메모리 할당 기법을 말합니다. 불연속 할당 기법으로는 페이징기법,세그먼테이션기법,페이지드 세그먼테이션 기법이 있다.
