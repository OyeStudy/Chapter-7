# 메모리 관리
## 1. 주소 바인딩
프로그램이 실행을 위해 메모리에 적재되면 그 프로세스를 위한 독자적인 주소 공간이 생성된다. 이 주소를 `논리적 주소 혹은 가상 주소` 라고 부른다.
#### 논리적 주소(logical address)
- 각 프로세스마다 독립적으로 할당되며 0번지부터 시작된다.
#### 물리적 주소(physical address)
- 물리적 메모리에 실제로 올라가는 위치를 말한다.
- 보통 물리적 메모리의 낮은 주소 영역에는 운영체제가 올라가고
- 높은 주소 영역에는 사용자 프로세스들이 올라간다.

CPU가 기계어 명령을 수행하기 위해 논리적 주소가 물리적 주소의 어느 위치에 매핑되는지 확인해야하는 주소 바인딩 작업이 필요하다.
### 주소 바인딩(address binding)
> 프로세스의 논리적 주소를 물리적 주소로 연결시켜주는 작업

주소 바인딩의 방식은 프로그램이 적재되는 물리적 메모리의 주소가 결정되는 시기에 따라 세 가지로 분류할 수 있다.
#### 1. 컴파일 타임 바인딩(compile time binding)
- 물리적 주소가 프로그램을 컴파일할 때 결정되는 주소 바인딩 방식
- 컴파일을 하는 시점에 해당 프로그램이 물리적 메모리의 몇 번지에 에치할 것인지 결정한다.
- 프로그램이 절대주소로 적재된다는 뜻에서 `절대코드(absolute code)` 바인딩 방식이라고도 한다.
- 프로그램의 물리적 메모리의 위치 변경시 컴파일을 다시 하는 수고가 필요하다.
- 따라서 컴파일 타임 바인딩 방식은 비현실적이고 편대의 시분할 컴퓨팅 환경에서는 잘 사용하지 않는 기법이다.
#### 2. 로드 타임 바인딩(load time binding)
- 프로그램의 실행이 시작될 때에 물리적 메모리 주소가 결정되는 주소 바인딩 방식
- `로더`의 책임하에 물리적 주소가 부여된다.
   - 로더(loader) : 사용자 프로그램을 메모리에 적재시키는 프로그램
- 프로그램이 종료될 때까지 물리적 메모리상의 위치가 고정된다.
- 컴퍼일러가 재배치 기능 코드(relocatable code)를 생성한 경우에 가능한 주소 바인딩 방식
#### 3. 실행시간 바인딩(execution time binding or run time binding)
- 프로그램이 실행을 시작한 후에도 그 프로그램이 위치한 물리적 메모리상의 주소가 변경될 수 있는 바인딩 방식
- 이 방식에서는 CPU가 주소를 참조할 때마다 주소 매핑 테이블(address mapping table)을 이용해 바인딩을 점검해야한다.
- 다른 바인딩 방식과 달리 실행시간 바인딩이 가능케하기 위해 기준 레지스터(base register)와 한계 레지스터(limit register)를 포함해 `MMU`가 뒷받침 되어야 한다.
   - MMU(Memory Management Unit : 메모리 관리 유닛) : 논리적 주소를 물리적 주소로 매핑해주는 하드웨어 장치

### MMU 기법 (MMU scheme)
가장 기본적인 방식으로 주소변환을 수행하는 기법
- 그 주소 값에 `기준 레지스터`의 값을 더해 물리적 주소값을 얻어낸다.
   - 기준 레지스터는 재배치 레지스터(relocation register)라고도 하며 프로세스의 물리적 메모리 시작 주소를 갖고 있다.
   - offset 개념
- 프로그램의 주소 공간이 물리적 메모리의 한 장소에 연속적으로 적재되는 것으로 가정한다.
- 따라서 그 프로그램이 적재되는 물리적 메모리상의 시작 주소만 알면 주소 변환을 쉽게 할 수 있다.
- 사용자 프로그램이나 CPU는 논리적 주소만을 다룰 뿐, 실제 물리적 주소는 알지 못하며 알 필요도 없다.
- 문맥교환으로 CPU에서 수행 중인 프로세스가 바꾸리 때 마다 각 프로세스에 맞는 서로 다른 N번지 위치에 접근하는 것을 지원한다.
![MMU 기법에 의한 주소 변환](https://velog.velcdn.com/images/zzallang/post/3561eaec-7756-46e8-887b-6997d7fd2d05/image.png)

   - 단점 : 물리적 메모리 안에는 여러 개의 프로세스가 동시에 올라가 있기 때문에 MMU 방식으로 사용하여 주소 변환을 했을 경우 CPU가 요청한 논리적 주소값과 재배치 레지스터 안에 있는 값을 더한 결과가 해당 프로세스의 주소 공간을 벗어나는 경우가 발생할 수 있다. 이렇게 되면 `메모리 보안(memory protection)`이 이루어지지 않아 다른 사람이 수행 중인 프로그램 영역을 침범하거나 메모리 영역을 변경해 시스템에 치명 적인 결과를 초래할 수도 있다.
   - 방안 : 한계 레지스터를 사용해 CPU가 메모리 참조 요청을 했을 때 프로세스가 자신의 주소 공간을 넘어서면 트랩을 발생시켜 해당 프로세스를 강제 종료 시킨다.
   ![기준 레지스터와 한계 레지스터에 의한 주소 변환](https://velog.velcdn.com/images/zzallang/post/d6f93291-8f70-4a0b-9100-ead951504945/image.jpg)
***
## 2. 메모리 관리와 관련된 용어
### 1) 동적로딩(dynamic loading)
- 여러 프로그램이 동시에 메모리에 올라가서 수행되는 다중 프로그래밍 환경에서 메모리 사용의 효율성을 높이기 위해 사용하는 기법 중 하나
- 프로세스가 주소 공간 전체를 메모리에 다 올려놓는 것이 아니라 해당 부분이 호출될 때 그 부분만을 메모리에 적재하는 방식
- 사용하지 않을 많은 양의 코드가 메모리에 올라가는 것을 막아 메모리를 좀 더 효율적으로 사용할 수 있도록 한다.
- 운영체제의 특별한 자원 없이 프로그램 자체에서 구현이 가능하며 운영체제가 라이브러리를 통해 지원할 수도 있다.
### 2) 동적연결(dynamic linking)
- 연결이란 프로그래머가 작성한 소스 코드를 컴파일하여 생성된 목적 파일(object file)과, 이미 컴파일된 라이브러리 파일(library file)들을 묶어 하나의 실행파일을 생성하는 과정
- 컴파일을 통해 생성된 목적 파일과 라이브러리 파일 사이의 연결을 프로그램의 실행 시점까지 지연시키는 기법
- 동적연결↔정적연결
   - 정적연결(static linking) : 프로그래머가 작성한 코드와 라이브러리 코드가 모두 합쳐져서 실행파일이 생성된다.
   - 실행파일의 크기가 상대적으로 크며, 동일한 라이브러리를 각 프로세스가 개별적으로 메모리에 적재해야 하므로 메모리가 낭비되는 단점이 있다
- 라이브러리가 실행 시점에 연결된다.
- 실행파일의 라이브러리 호출 부분에 라이브러리 호출 시 스텁이라는 작은 코드를 둔다.
- 라이브러리 호출 시 스텁을 토해 해당 라이브러리가 메모리에 이미 존재하는지 살펴보고 존재한다면 그 주소의 메모리 위치에서 직접 참조하며 존재하지 않다면 디스크에서 동적 라이브러리 파일을 찾아 메모리로 적재한 후 수행하게 된다.
- 다수 프로그램이 공통으로 사용하는 라이브러리를 메모리에 한 번만 적재하므로 메모리 사용의 효율성을 높일 수 있다
- 운영체제의 지원을 필요하다.
### 3) 중첩(overlays)
- 프로세스의 주소 공간을 분할해 실제 필요한 부분만을 메모리에 적재하는 기법
- 프로세스의 주소 공간을 분할해서 당장 필욯나 일부분을 메모리에 올려 실행하고 해당 부분에 대한 실행이 끝난 후에 나머지 부분을 올려 실행하는 기법
- 동적로딩과 개념적으로 유사하지만 동적로딩은 메모리에 더 많은 프로세스를 동시에 올려놓고 실행하기 위한 용도인 반면, 중첩은 단일 프로세스만을 메모리에 올려놓는 환경에서 메모리 용량보다 큰 프로세스를 실행하기 위한 어쩔 수 없는 선택이였다.
- 중첩은 운영체제의 지원이 없고 프로그래머가 직접 구현되어야 했으며 수작업 중첩(manual overlays)라고도 부른다.
### 4) 스와핑 기법(swapping)
- 스와핑은 메모리에 올라온 프로세스의 주소 공간 전체를 디스크의 `스왑 영역`에 일시적으로 내려놓는 것을 말한다.
  - 스왑 영역(swap area) : 
    - 백킹스토어(backing store)라고도 부르며, 디스크 내에 파일 시스템과는 별도로 존재하는 일정 영역을 말한다.
    - 스왑 영역은 프로세스가 수행 중인 동안에만 디스크에 일시적으로 저장하는 공간이므로 저장 기간이 상대적으로 짧은 저장공간이라고 할 수 있다.
    - 다수의 사용자 프로세스를 담을 수 있을 만큼 충분히 큰 저장공간이어야 하고 어느 정도의 저 접근 속도가 보장되어야 한다.
- 스와핑은 프로세스가 종료되어 그 주소 공간을 디스크로 내쫓는 것이 아니라, 특정한 이유로 수행 중인 프로세스의 주소 공간을 일시적으로 메모리에서 디스크로 내려놓는 것을 의미한다.
- `스왑 인(swap in)` : 디스크에서 메모리로 올리는 작업
- `스왑 아웃(swap out)` : 메모리에서 디스크로 내리는 작업
- 스와핑이 일어나는 과정 : 
  - 1. 스와퍼(swapper)라고 불리는 중기 스케줄러에 의해 스왑 아웃시킬 프로세스를 선정한다.
  - 2. 스왑 아웃 대상으로 선정된 프로세스는 메모리에 올라가 있는 주소 공간의 내용을 통째로 스왑 아웃 시키게 된다
- 메모리에 존재하는 프로세스의 수를 조절하는 역할
- 컴파일 타임 바인딩 방식과 로드 타임 바인딩 방식에서는 스왑 아웃된 프로세스가 다시 스왑 인될 때에는 원래 존재하던 메모리 위치로 다시 올라가야하나 실행시간 바인딩 기법은 추후 빈 메모리 영역 아무곳에나 프로세스를 올릴 수 있다.
- 스와핑에서는 디스크 내의 스왑 영역에 프로세스 주소 공간이 순차적으로 저장
  - 스와핑에 서요되는 시간은 디스크의 탐색시간(seek time)이나 회전지연시간(rotational latency)보다는 디스크 섹터에서 실제 데이터를 읽고 쓰는 전송 시간(transfer time)이 대부분을 차지한다.
  
![스와핑의 예](https://velog.velcdn.com/images/zzallang/post/42ac370b-6345-4db0-9be0-dad91bce5d38/image.png)
***
## 3. 물리적 메모리의 할당 방식
### 사용자 프로세스 영역의 관리 방법
#### 연속할당(contiguous allocation)
- 각각의 프로세스를 물리적 메모리의 연속적인 공간에 올리는 방식
- 물리적 메모리를 다수의 분할로 나누어 하나의 분할에 하나의 프로세스가 적재되도록 한다.
  - 고정분할(fixed partition allocation) : 물리적 메모리를 고정된 크기의 분할로 미리 나누어 두는 방식
  - 가변분할(variable partition allocation) : 프로그램이 실행되고 종료되는 순서에 따라 분할을 관리하는 방식
#### 불연속할당(noncontiguous allocation)
- 하나의 프로세스를 물리적 메모리의 여러 영역에 분산해 적재하는 방식
- 페이징 기법,세그먼테이션 기법, 페이지드 세그먼테이션 기법 등이 있다.
### 1) 연속할당 방식
고정분할 방식과 가변분할 방식으로 나뉘어진 크기에 물리적 메모리의 한 곳에 연속적으로 적재한다.
#### 고정분할 방식
- 물리적 메모리를 주어진 개수만큼 영구적인 분할(partition)으로 나누고 각 분할에 하나의 프로세스를 적재한다.
- 분할의 크기가 동일할 수도 아닐 수도 있다.
- 동시에 메모리에 올릴 수 있는 프로그램의 수가 고정되어 있으며 수행 가능한 프로그램의 최대 크기 또한 제한된다는 점에서 가변 분할 방식에 비해 융통성이 떨어진다.
- `외부조각`과 `내부조각`이 발생할 수 있다.
  - 외부조각(external fragmentation) : 
    - 프로그램의 크기보다 분할크기가 작은 경우 해당 분할이 비어 있는데도 불구하고 프로그램을 적재하지 못하기 때문에 발생하는 메모리 공간을 의미
    - 즉 어떤 프로그램에게도 배정되지 않은 빈 공간임에도 현재 상태에서 사용할 수 없는 작은 분할이다.
    - 만약 이 외부조각의 크기보다 작은 크기의 프로그램이 도착한다면 외부 조각에 적재할 수 있다.
  - 내부조각(internal fragmentation) : 
    - 프로그램의 크기보다 분할의 크기가 큰 경우 해당 분할에 프로그램을 적재하고 남는 메모리 공간을 의미
    - 즉 하나의 분할 내부에서 발생하는 사용되지 않는 메모리 조각을 말한다.
    - 내부조각에 수용할 수 있는 충분히 작은 크기의 프로그램이 있다 해도 공간을 활용할 수 없어 메모리가 낭비된다.
#### 가변분할 방식
- 고정분할 방식과 달리 메모리에 적재되는 프로그램의 크기에 따라 분할의 크기,개수가 동적으로 변하는 방식을 말한다.
- 프로그램의 크기를 고려해서 메모리를 할당하고 이를 기술적으로 관리할 수 있는 기법을 필요로 한다.
- 내부조각은 발생하지 않으나 이미 메모리에 존재하는 프로그램이 종료될 경우 중간에 빈 공간이 발생하게 되며, 이 공간이 새롭게 시작되는 프로그램의 크기보다 작을 경우 외부조각이 발생할 가능성이 있다.
- `동적 메모리 할당 문제`가 생김
  - 동적 메모리 할당 문제 (dynamic storage-allocation problem) : 주소 공간의 크기가 n인 프로세스를 메모리에 올릴 때 물리적 메모리 내 `가용 공간` 중 어떤 위치에 올릴 것인지 결정하는 문제
    - 가용 공간 : 사용되지 않은 메모리 공간으로서 메모리 내의 여러 곳에 산발적으로 존재할 수 있다.
- 새로운 프로세스를 메모리에 올리기 위해 프로세스 주소 공간 전체를 담을 수 잇는 가용 공간을 찾아야 한다.
#### 동적 메모리 할당 문제의 해결책
1. 최초적합(first-fit) 방법 :
- 크기가 n 이상인 가용 공간 중 가장 먼저 찾아지는 곳에 프로세스를 할당하는 방법
- 시간적인 측면에서 효율적
2. 최적적합(best-fit) 방법 : 
- 크기가 n 이상인 가장 작은 가용 공간을 찾아 그곳에 새로운 프로그램을 할당하는 방법
- 시간적 오버헤드가 발생하고 다수의 매우 작은 가용 공간들이 생성될 수 있다는 단점이 있음
- 공간적인 측면에서 효율적
3. 최악적합(worst-fit) 방법 : 
- 가용 공간 중에서 가장 크기가 큰 곳에 새로운 프로그램을 할당하는 방법
- 오버헤드가 발생한다.
- 가용 공간을 빨리 소진하는 단점이 있다.
#### 외부조각이 발생하는 문제의 해결책
- 컴팩션(compaction) : 물리적 메모리 중에서 프로세스에 의해 사용 중인 메모리 영역을 한쪽으로 몰고 가용 공간들을 다른 한쪽으로 모아서 하나의 큰 가용 공간을 만드는 방법
- 현재 수행 중인 프로세스의 메모리상의 위치를 상당 부분 이동시켜야 하므로 비용이 매우 많이 드는 작업
- 수행 중인 프로세스의 물리적 메모리 위치를 옮겨야하므로 프로그램 시간 도중에 프로세스의 주소가 동적으로 바뀌는 실행시간 바인딩 방식이 지원될 때만 가능하다.
### 2) 불연속할당 기법
- 하나의 프로세스가 물리적 메모리의 여러 위치에 분산되어 올라갈 수 있는 메모리 할당 기법
- 페이징(paging) 기법 : 각 프로세스의 주소 공간을 동일한 크기의 페이지로 잘라서 메모리에 페 이지 단위로 적재 시키는 기법
- 세그먼테이션(segmentation) 기법 : 프로그램의 주소 공간을 코드,데이터,스택 등 의미있는 단위인 세그먼트로 나누어 세그먼트 단위로 적재하는 기법
- 페이지드 세그먼테이션(paged segmentation) 기법 : 세그먼트 하나를 다수의 페이지로 구성하는 기법