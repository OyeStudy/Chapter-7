- 메모리는 주소를 통해 접근하는 저장장치이다.
- 주소(address)란 서로 다른 위치를 구분하기 위해 사용하는 일련의 숫자로 구성되며, 컴퓨터는 이진수를 사용하므로 메모리 주속는 이진수로 매겨지게 된다.
- 컴퓨터 시스템은 32비트 혹은 64비트의 주소 체계를 사용하고 있다.
- 32비트의 주소 체계를 사용할 경우 2^32가지의 서로 다른 메모리 위치를 구분할 수 있게 된다.
- 컴퓨터에서는 byte 단위로 메모리 주소를 부여한다.
- 컴퓨터 상의 주소도 32비트를 그대로 사용하지 않고 효율적인 운영을 위해 연속된 일련의 영역을 보통 4KB(=2^12byte) 단위로 묶어 페이지(page)라는 구역을 만들어 사용한다.
- 페이지 하나의 크기가 2^12바이트이므로 페이지 내에서 바이트별 위치 구분을 위해서는 12비트가 필요하며, 총 32비트의 주소 중 하위 12비트는 페이지 내에서의 주소를 나타나게 된다.

### 1. 주소 바인딩

- 프로그램이 실행을 위해 메모리에 적재되면 그 프로세스를 위한 독자적인 주소 공간이 생성되고, 이 주소를 논리적 주소(logical address) 혹은 가상 주소(virtual address)라고 부른다.
- 논리적 주소는 각 프로세스마다 독립적으로 할당되며 0번지부터 시작된다.

#### 물리적 주소(physical address)

- 메모리에 실제로 올라가는 위치를 말한다.
- 낮은 주소 영역에는 운영체제, 높은 주소 영역에는 사용자 프로세스들이 올라간다.

- 프로세스가 실행되기 위해서는 해당 프로그램이 물리적 메모리에 올라가 있어야 하고, CPU가 기계어 명령을 수행하기 위해 논리적 주소를 통해 메모리 참조를 하게 되는데, 이렇게 프로세스의 논리적 주소를 물리적 메모리 주소를 연결시켜주는 작업을 `주소 바인딩(address binding)`이라고 한다.

#### 주소 바인딩

- 프로그램이 적재되는 물리적 메모리의 주소가 결정되는 시기에 따라 세 가지로 분류할 수 있다.

1. 컴파일 타임 바인딩(compile time binding)
   - 물리적 메모리 주소가 프로그램을 컴파일할 때 결정되는 주소 바인딩 방식
   - 비현실적이고 현대의 시분할 컴퓨팅 환경에서는 잘 사용하지 않는 기법


2. 로드 타임 바인딩(load time binding)
   - 프로그램의 실행이 시작될 때에 물리적 메모리 주소가 결정되는 주소 바인딩 방식
   - `로더(loader)`의 책임하에 물리적 메모리 주소가 부여되며 프로그램이 종료될 때까지 물리적 메모리상의 위치가 고정된다.
   `로더` : 사용자 프로그램을 메모리에 적재시키는 프로그램
   - 로드 타임 바인딩은 컴파일러가 재배치 가능 코드(relocatable code)를 생성한 경우에 가능한 주소 바인딩 방식
   
3. 실행시간 바인딩(execution time binding 또는 rut time binding)   
   - 프로그램이 실행을 시작한 후에도 그 프로그램이 위치한 물리적 메모리상의 주소가 변경될 수 있는 바인딩 방식
   - CPU가 주소를 참조할 때마다 해당 데이터가 물리적 메모리의 어느 위치에 존재하는지, 주소 매핑 테이블(address mapping table)을 이용해 바인딩을 점검해야 한다.
   - `기준 레지스터(base register)`와 `한계 레지스터(limit register)`를 포함해 `MMU(Memory Management Unit: 메모리 유닛 관리)`라는 하드웨어적인 지원이 뒷받침되어야 한다.
   `MMU` : 논리적 주소를 물리적 주소로 매핑해주는 하드웨어 장치
   `한계 레지스터` : 프로세스가 자신의 주소 공간을 넘어서는 메모리 참조를 하려고 하는지 체크하는 용도로 사용되며, 현재 CPU에서 수행 중인 프로세스 논리적 주소의 최댓값, 즉 그 프로세스의 크기를 담고 있다.
   
### 2. 메모리 관리와 관련된 용어

#### 1) 동적로딩

- 동적로딩(dynamic loading)은 여러 프로그램이 동시에 메모리에 올라가서 수행되는 다중 프로그래밍(multi-programming) 환경에서 메모리 사용의 효율성을 높이기 위해 사용하는 기법 중 하나이다.
- 프로세스 내에서 실행에 필요한 부분이 실제로 불릴 때마다 메모리에 적재하는 방식
- 운영체제의 특별한 지원 없이 프로그램 자체에서 구현이 가능하며 운영체제가 라이브러리를 통해 지원할 수도 있다.

#### 2) 동적연결

- 동적연결(dynamic linking)은 컴파일을 통해 생성된 목적 파일과 라이브러리 파일 사이의 연결을 프로그램의 실행 시점까지 지연시키는 기법
- 라이브러리가 실행 시점에 연결
- 실행파일의 라이브러리 호출 부분에 해당 라이브러리의 위치를 찾기 위한 `스텁(stub)`이라는 작은 코드를 둔다.
- 운영체제의 지원을 필요로 한다.

#### 정적연결
- 동적연결과 대비되는 개념인 `정적연결(static linking)`에서는 프로그래머가 작성한 코드와 라이브러리 코드가 모두 합쳐져서 실행파일이 생성된다.
- 실행파이의 크기가 상대적으로 크다.
- 동일한 라이브러리를 각 프로세스가 개별적으로 메모리에 적재해야 하므로 물리적 메모리가 낭비되는 단점이 있다.

#### 3) 중첩

- 중첩(overlays)이란 프로세스의 주소 공간을 분할해 실제 필요한 부분만을 메모리에 적재하는 기법을 말한다.
- 운영체제의 지원 없이 프로그래머에 의해 구현되어야 했으며, 작은 공간의 메모리를 사용하던 초창기 시스템에서 프로그래머가 손수 구현했다 해서 수작업 중첩(manual overlays)이라고도 부른다.
- 직접 중첩을 구현하는 것은 상당한 복잡한 작업이다

#### 4) 스와핑

- 스와핑(swapping)이란 메모리에 올라온 프로세스의 주소 공간 전체를 디스크의 스왑 영역(swap area)에 일시적으로 내려놓는 것을 말한다.
- 스왑 영역은 백킹스토어(backing store)라고도 부르며, 디스크 내에 파일 시스템과는 별도로 존재하는 일정 영역을 말한다.
- `스왑 인(swap in)` : 디스크에서 메모리로 올리는 작업
- `스왑 아웃(swap out)` : 메모리에서 디스크로 내리는 작업

### 3. 물리적 메모리의 할당 방식

- 물리적 메모리는 `운영체제 상주 영역`과 `사용자 프로세스 영역`으로 나뉘어 사영된다.
- `운영체제 상주 영역` : 
인터럽트 백터와 함께 물리적 메모리의 낮은 주소 영역을 사용
운영체제 커널이 위치
- `사용자 프로세스 영역` :
물리적 메모리의 높은 주소 영역을 사용
여러 사용자 프로세스들이 이곳에 적재되어 실행 된다

- 사용자 프로세스 영역의 관리 방법은 프로세스를 메모리에 올리는 방식에 따라 `연속할당(contiguous allocation) 방식`과 `불연속할당(noncontiguous allocation) 방식`으로 나뉘어볼 수 있다.
- `연속할당 방식` :
각각의 프로세스를 물리적 메모리의 연속적인 공간에 올리는 방식
물리적 메모리를 다수의 분할로 나누어 하나의 분할에 하나의 프로세스가 적재되도록 한다.
분할을 관리하는 방식에 따라 `고정분할(fixed partition allocation) 방식`과 `가변분할(variable partition allocation) 방식`으로 다시 나뉘어볼 수 있다.
- `불연속할당 방식` : 
하나의 프로세스를 물리적 메모리의 여러 영역에 분산해 적재하는 방식
`페이징(paging) 기법`, `세그먼테이션(segmentation) 기법`, `페이지드 세그먼테이션(paged segmentation) 기법` 등이 있다.

#### 1) 연속할당 방식
- 프로세스를 메모리에 올릴 때 그 주소 공간을 여러 개로 분할하지 않고 물리적 메모리의 한 곳에 연속적으로 적재하는 방식
- 물리적 메모리를 고정된 크기의 분할로 미리 나누어 놓는지 그렇지 않은지에 따라 `고정분할 방식`과 `가변분할 방식`을 나뉜다.

- `고정분할 방식`
  - 물리적 메모리를 주어진 개수만큼의 영구적인 분할(partition)로 미리 나누어두고 각 분할에 하나의 프로세스를 적재해 실행시킬 수 있게 한다.
  - 두 방식 모두 하나의 분할에는 하나의 프로그램만을 적재할 수 있다.
  - 동시에 메모리에 올릴 수 있는 프로그램의 수가 고정되어 있으며 수행 가능한 프로그램의 최대 크기 도한 제한된다는 점에서 가변분할 방식에 비해 융통성이 덜어진다.
  - `외부조각(external fragmentation)`
  프로그램의 크기보다 분할의 크기가 작은 경우 해당 분할이 비어 있는데도 불구하고 프로그램을 적재하지 못하기 때문에 발생하는 메모리 공간
  - `내부조각(internal fragmentation)`
  프로그램의 크기보다 분할의 크기가 큰 경우 해당 분할에 프로그램을 적재하고 남는 메모리 공간
  내부조각에 수용할 수 있는 작은 크기의 프로그램이 있다 해도 공간을 활용할 수 없어 메모리가 낭비 된다.

- `가변분할 방식`
  - 고정분할 방식과 달리 메모리에 적재되는 프로그램의 크기에 따라 분할의 크기, 개수가 동적으로 변하는 방식
  - 분할의 크기를 프로그램의 크기보다 일부러 크게 할당하지는 않기 때문에 내부조각을 발생하지 않는다.
  - 가변분할 방식에서 주요하게 다루는 쟁점 중 하나는 주소 공간의 크기가 n인 프로세스를 메모리에 올릴 때 물리적 메모리 내 `가용 공간` 중 어떤 위치에 올릴 것인지를 결정하는 문제이다. 이를 `동적 메모리 할당 문제(dynamic storage-allocation problem)`라고도 부른다.
  `가용 공간` : 사용되지 않은 메모리 공간으로서 메모리 내의 여러 곳에 산발적으로 존재
  - `동적 메모리 할당 문제(dynamic storage-allocation problem)` 해결하는 대표적인 방법
    1. 크기가 n이상인 가용 공간 중 가장 먼저 찾아지는 곳에 프로세스를 할당하는 최초적합(first-fit) 방법
    2. 크기가 n이상인 가장 작은 가용 공간을 찾아 그곳에 새로운 프로그램을 할당하는 최적적합(best-fit) 방법
    3. 가용 공간 중에서 가장 크기가 큰 곳에 새로운 프로그램을 할당하는 최악적합(worst-fit) 방법
    - 세 가지 방법에 대해 실제 시스템에서 실험한 결과에 따르면 `최초적합`과 `최적적합 방식`이 `최악적합 방식`에 비해 속도와 공간 이용률 측면에서 효과적인 것으로 알려짐
  - `컴팩션(compaction)` : 
  가변분할 방식에서 발생하는 외부조각 문제를 해결하기 위한 방법
  물리적 메모리 중에서 프로세스에 의해 사용 중인 메모리 영역을 한쪽으로 몰고 가용 공간들을 다른 한쪽으로 모아서 하나의 큰 가용 공간을 만드는 방법
  
#### 2) 불연속할당 기법
-  하나의 프로세스가 물리적 메모리의 여러 위치에 분산되어 올라갈 수 있는 메모리 할당 기법
- `페이징(paging) 기법`, `세그먼테이션(segmentation) 기법`, `페이지드 세그먼테이션(paged segmentation) 기법` 등이 있다.
`페이징(paging) 기법` 프로그램을 분할하는 기준에 따라 동일한 크기로 나뉘어 메모리에 올리는 기법
`세그먼테이션(segmentation) 기법` 크기는 일정하지 않지만 의미 단위로 나누어 메모리에 올리는 기법
`페이지드 세그먼테이션(paged segmentation) 기법` 세그먼테이션을 기본으로 하되 이를 다시 동일 크기의 페이지로 나누어 메모리에 올리는 기법

---

   
